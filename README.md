# TMP-memoization

## 1.왜 만들었는가? - C++ TMP 학습 목적

C++ 템플릿 메타프로그래밍(TMP)을 학습 및 실습하기 위해 메모이제이션(memoization) 라이브러리를 직접 설계·구현하였다.
단순 문법 학습이 아니라, 컨셉(concepts), 태그 디스패치, 부분 특수화, 정책 기반 설계를 모두 사용하는 실용적인 예제를 목표로 삼았다.

---

## 2.무엇을 구현했는가? - TMP를 활용한 메모이제이션 라이브러리

C++ TMP를 활용하여 다음과 같은 특징을 가진 범용 메모이제이션 라이브러리를 구현하였다.

1. 임의의 함수를 감싸 캐시 가능한 함수 객체로 만드는 memoization 템플릿 클래스

2. 컨테이너 정책 :
    - ordered 태그 -> std::map 기반 캐시
    - unordered 태그 -> std::unordered_map 기반 캐시

3. 캐시 제한 정책 :
    - unlimited : 무제한 캐시
    - limited<N> : std::size_t 상수 인자만큼의 데이터를 저장하고, 초과 시 LRU(Latest Recently Used) 방식으로 제거
      
4. 인자 튜플을 키로 사용하는 캐시 구조
    - std::tuple<함수 인자...>를 키로 사용

---

## 3.어떤 점이 차별점인가?

TMP를 사용하지 않고 일반적인 형태로 구현한 메모이제이션 기능은 다음과 같은 단점을 가진다.
- 특정 함수 전용의 컨테이너를 사용하여 인자들과 반환값을 저장한다.
- 반환 타입, 인자 타입, 컨테이너 타입 등이 고정되어 재사용성이 떨어진다.
- 캐시 크기 제한, 반환값 타입 제한 등 정책 적용을 위해선 매번 별도의 구현이 필요하다.

반면에 TMP를 활용한 메모이제이션 라이브러리는 설정된 제약을 만족하면 어떤 함수라도 사용할 수 있다.

또한 반환 타입, 인자 타입, 컨테이너 타입 등이 고정되어있지 않아, 범용적인 사용이 가능하다.

이를 통해 함수별로 특수화된 메모이제이션 기능을 구현하지 않아도 되므로 편리하게 사용할 수 있다.

---

해당 TMP 라이브러리는 다음과 같은 설계를 통해 차별점을 같는다.

1. 정책 기반 설계
  - 컨테이너 (ordered / unordered),  캐시 제한을 템플릿 인자와태그 타입으로 분리함.
  - 동일한 메모이제이션 코드를 유지한 채, 정책 조합만 바꿔서 다양한 캐시 전략을 선택할 수 있음.
  - 반환 값에 제약을 걸어두어 부주의한 라이브러리 사용을 억제할 수 있음.
  - 필요한 경우 정책들을 추가하여 확장 가능함.
  - 
2. C++20 concepts를 통한 타입 제약
  - 정책 제약을 통해 정책에 어긋나는 조합은 컴파일 시점에 차단함.

3. TMP를 활용한 LRU 구현 구조 분리
  - LRU 기능은 캐시 제한 정책을 사용할 때만 필요하므로 해당 정책이 사용될 때만 코드가 생성됨. 이를 통해 불필요한 코드 생성을 줄임.

4. 범용 함수 / 람다 지원
  - 내부적으로 std::function을 사용해, 일반적인 함수,람다,펑터 등 대부분의 호출 가능 객체를 사용할 수 있도록 설계함. 

---

## 4.상세 구현

1. 정책 태그 및 컨셉 정의
    - 컨테이너 정책 태그
    ```cpp
    struct ordered {};
    struct unordered {};

    template <typename Policy>
    struct container_of;

    template <>
    struct container_of<ordered> {
        using type = std::map</* key = std::tuple<Args...>, value = R */>;
    };
    
    template <>
    struct container_of<unordered> {
        using type = std::unordered_map</* key = std::tuple<Args...>, value = R */>;
    };
    
    template <typename Policy>
    using container_t = typename container_of<Policy>::type; 



## 5.결과
1. C++ 20 TMP와 Concepts을 활용하여 정책 기반 메모이제이션 라이브러리를 설계, 구현하였다.
2. 컨테이너 정책, 캐시 제한 정책을 컴파일 타임에 조합 가능하도록 일반화했으며, 잘못된 조합은 컴파일 타임에서 차단된다.
3. 처음 설계할 때는 구체화된 코드를 작성하고, 단계적으로 일반화 시켜나가는 과정을 통해 범용적인 코드를 작성할 수 있었다.
   이 과정을 통해 일반화 프로그래밍 설계를 경험하고, 프로그래밍 실력을 높일 수 있었다. 
4. std::tuple 키와 전용 해시 특수화, 상속을 통한 선택적인 코드 구현 등 개발 과정에서 여러 어려움을 겪고 이를 해결하는 과정을 통해 TMP와 정책 기반 패턴에 대해 깊게 이해할 수 있었다.
5. 추후 타입 추론 기능을 추가하여 복잡한 정책 기입을 줄이고 더욱 편리하게 사용할 수 있도록 개선하고자 한다.

---
